# data file for the Fltk User Interface Designer (fluid)
version 1.0108 
header_name {.H} 
code_name {.C}
decl {const float STATUS_UPDATE_FREQ = 0.5f;} {} 

decl {\#include "Fl_Menu_Settings.H"} {} 

decl {\#include "Timeline.H"} {} 

decl {\#include "Engine.H"} {} 

decl {\#include "Transport.H"} {} 

decl {\#include "Loggable.H"} {} 

decl {\#include "Clock.H"} {public
} 

decl {\#include "Track.H" // for capture_format} {} 

decl {\#include "Audio_File.H" // for supported formats} {} 

decl {\#include "Waveform.H" // for options} {} 

decl {\#include "Region.H" // for options} {} 

decl {\#include "Control_Sequence.H" // for options} {} 

decl {\#include <FL/fl_ask.H>} {} 

decl {\#include <FL/Fl.H>} {} 

decl {extern char *user_config_dir;} {global
} 

class TLE {open
} {
  decl {Fl_Color system_colors[3];} {selected public
  }
  decl {static void menubar_cb ( void *v )} {}
  decl {void menubar_cb ( void )} {}
  Function {menu_picked_value( const Fl_Menu_ *m )} {open return_type {static int}
  } {
    code {return m->menu()[ m->value() ].flags & FL_MENU_VALUE;} {}
  }
  Function {save()} {open
  } {
    code {const char options_filename[] = "options";
// const char state_filename[] = "state";

// save options

char *path;
asprintf( &path, "%s/%s", user_config_dir, options_filename );
((Fl_Menu_Settings*)menubar)->dump( menubar->find_item( "&Options" ), path );
free( path );

// save unjournaled state

// Loggable::save_unjournaled( state_filename );} {}
  }
  Function {capture_format_cb( Fl_Widget *w, void *v )} {open private return_type {static void}
  } {
    code {((TLE*)v)->capture_format_cb();} {}
  }
  Function {capture_format_cb()} {open private return_type void
  } {
    code {Fl_Menu_ *o = menubar;

Track::capture_format = o->menu()[ o->value() ].label();} {}
  }
  Function {TLE()} {open
  } {
    code {make_window();

// Fl::visual( RGB8 );
Fl::visible_focus( 0 );

Fl::get_system_colors();
Fl::scheme( "plastic" );

system_colors[ 0 ] = (Fl_Color)Fl::get_color( FL_BACKGROUND_COLOR );
system_colors[ 1 ] = (Fl_Color)Fl::get_color( FL_FOREGROUND_COLOR  );
system_colors[ 2 ] = (Fl_Color)Fl::get_color( FL_BACKGROUND2_COLOR  );

Fl::add_timeout( STATUS_UPDATE_FREQ, update_cb, this );



std::list <const char *> formats;

Audio_File::all_supported_formats( formats );

for ( std::list <const char *>::const_iterator f = formats.begin(); f != formats.end(); ++f )
{
//	capture_format_menu->add( *f, FL_MENU_RADIO, 0, 0, 0 );
//;
	char pat[256];
	snprintf( pat, sizeof( pat ), "Timeline/Capture Format/%s", *f );	

	menubar->add( pat, 0, &TLE::capture_format_cb, this, FL_MENU_RADIO );
}


char *path;
asprintf( &path, "%s/options", user_config_dir );
((Fl_Menu_Settings*)menubar)->load( menubar->find_item( "&Options" ), path );
free( path );} {}
  }
  Function {make_window()} {open
  } {
    Fl_Window main_window {
      label {Non-DAW - Timeline} open
      xywh {577 50 1024 768} type Double resizable xclass {Non-DAW} visible
    } {
      Fl_Menu_Bar menubar {open
        xywh {0 0 1024 25}
      } {
        Submenu {} {
          label {&Session} open
          xywh {0 0 74 25}
        } {
          MenuItem {} {
            label {&New}
            xywh {0 0 40 25}
          }
          MenuItem {} {
            label {&Open}
            xywh {10 10 40 25}
          }
          MenuItem {} {
            label {&Compact}
            callback {int n = fl_choice( "Compacting will replace the session history with a snapshot of the current state.\\n You will not be able to use Undo to go back beyond this point.\\n This operation is irreversible!", NULL, "Abort", "Procede with compaction" );

if ( n != 2 )
	return;
	
Loggable::compact();}
            xywh {20 20 40 25}
          }
          Submenu {} {
            label Export open
            xywh {0 0 74 25}
          } {
            MenuItem {} {
              label Session
              xywh {0 0 40 25}
            }
            MenuItem {} {
              label Range
              xywh {10 10 40 25}
            }
          }
          MenuItem {} {
            label {&Quit}
            callback {save();

exit( 0 );}
            xywh {40 40 40 25} shortcut 0x40071
          }
        }
        Submenu {} {
          label {&Edit} open
          xywh {0 0 74 25}
        } {
          MenuItem {} {
            label Preferences
            xywh {0 0 40 25}
          }
          MenuItem {} {
            label Undo
            callback {Loggable::undo();}
            xywh {0 0 40 25} shortcut 0x4007a
          }
        }
        Submenu {} {
          label Transport open
          xywh {0 0 74 25}
        } {
          MenuItem {} {
            label Home
            callback {transport->locate( 0 );}
            xywh {0 0 40 25} shortcut 0xff50
          }
          MenuItem {} {
            label End
            callback {transport->locate( timeline->length() );}
            xywh {10 10 40 25} shortcut 0xff57
          }
          MenuItem {} {
            label Stop
            callback {transport->stop();}
            xywh {20 20 40 25} shortcut 0x50073
          }
          MenuItem {} {
            label Play
            callback {transport->start();}
            xywh {30 30 40 25} shortcut 0x50070
          }
          MenuItem {} {
            label Record
            xywh {40 40 40 25} shortcut 0x50072
          }
        }
        Submenu {} {
          label {&View} open
          xywh {0 0 74 25}
        } {
          Submenu {} {
            label {&Zoom} open
            xywh {0 0 74 25}
          } {
            MenuItem {} {
              label {&In}
              callback {timeline->zoom_in();}
              xywh {20 20 40 25}
            }
            MenuItem {} {
              label {&Out}
              callback {timeline->zoom_out();}
              xywh {30 30 40 25}
            }
            MenuItem {} {
              label {&Fit}
              xywh {10 10 40 25} divider
            }
            MenuItem {} {
              label {1 sec.}
              callback {timeline->zoom( 1 );}
              xywh {10 10 40 25} shortcut 0x31
            }
            MenuItem {} {
              label {1 min.}
              callback {timeline->zoom( 60 );}
              xywh {20 20 40 25} shortcut 0x32
            }
            MenuItem {} {
              label {1 hour.}
              callback {timeline->zoom( 60 * 60 );}
              xywh {30 30 40 25} shortcut 0x33
            }
          }
        }
        Submenu timeline_menu {
          label {&Timeline} open
          xywh {0 0 74 25}
        } {
          Submenu {} {
            label {&Snap} open
            xywh {0 0 74 25}
          } {
            MenuItem {} {
              label Bars
              xywh {0 0 40 25} type Radio value 1
            }
            MenuItem {} {
              label Beats
              xywh {10 10 40 25} type Radio
            }
            MenuItem {} {
              label Off
              xywh {20 20 40 25} type Radio
            }
          }
          Submenu {} {
            label {Capture Format} open
            xywh {0 0 74 25}
          } {}
        }
        Submenu {} {
          label {&Options} open
          xywh {0 0 74 25} divider
        } {
          Submenu {} {
            label {&Display} open
            xywh {0 0 74 25}
          } {
            Submenu {} {
              label {&Timeline} open
              xywh {0 0 74 25}
            } {
              MenuItem {} {
                label {&Measure lines}
                callback {Timeline::draw_with_measure_lines = menu_picked_value( o );

timeline->redraw();}
                xywh {0 0 40 25} type Toggle value 1
              }
            }
            Submenu {} {
              label {&Waveforms} open
              xywh {0 0 74 25}
            } {
              MenuItem {} {
                label Fill
                callback {Waveform::fill = menu_picked_value( o );

timeline->redraw();}
                xywh {10 10 40 25} type Toggle value 1
              }
              MenuItem {} {
                label Outline
                callback {Waveform::outline = menu_picked_value( o );

timeline->redraw();}
                xywh {30 30 40 25} type Toggle value 1
              }
              MenuItem {} {
                label {Vary color}
                callback {Waveform::vary_color = menu_picked_value( o );

timeline->redraw();}
                xywh {20 20 40 25} type Toggle value 1
              }
            }
            Submenu {} {
              label {&Region} open
              xywh {0 0 74 25}
            } {
              MenuItem {} {
                label {Filled fades}
                xywh {30 30 40 25} type Toggle value 1
              }
              MenuItem {} {
                label {Inherit track color}
                callback {Region::inherit_track_color = menu_picked_value( o );

timeline->redraw();}
                xywh {40 40 40 25} type Toggle value 1
              }
            }
            Submenu {} {
              label {&Control Sequence} open
              xywh {0 0 74 25}
            } {
              MenuItem {} {
                label Polygon
                callback {Control_Sequence::draw_with_polygon = menu_picked_value( o );

timeline->redraw();}
                xywh {20 20 40 25} type Toggle value 1
              }
              MenuItem {} {
                label Graded
                callback {Control_Sequence::draw_with_gradient = menu_picked_value( o );

timeline->redraw();}
                xywh {30 30 40 25} type Toggle value 1
              }
              MenuItem {} {
                label Ruled
                callback {Control_Sequence::draw_with_grid = menu_picked_value( o );

timeline->redraw();}
                xywh {40 40 40 25} type Toggle value 1
              }
            }
            Submenu {} {
              label {&Style} open
              xywh {0 0 74 25}
            } {
              MenuItem {} {
                label Default
                callback {Fl::scheme( "plastic" );}
                xywh {0 0 40 25} type Radio value 1
              }
              MenuItem {} {
                label Flat
                callback {Fl::scheme( "gtk+" );}
                xywh {10 10 40 25} type Radio
              }
            }
            Submenu {} {
              label {C&olors} open
              xywh {0 0 74 25}
            } {
              MenuItem {} {
                label System
                callback {//Fl::get_system_colors();

unsigned char r, g, b;

Fl::get_color( system_colors[ 0 ], r, g, b );

Fl::background( r, g, b );

Fl::get_color( system_colors[ 1 ], r, g, b );

Fl::foreground( r, g, b );

Fl::get_color( system_colors[ 2 ], r, g, b );

Fl::background2( r, g, b );

Fl::scheme( Fl::scheme() );}
                xywh {0 0 40 25} type Radio
              }
              MenuItem {} {
                label Dark
                callback {Fl::background2( 100, 100, 100 );
Fl::background( 50, 50, 50 );
Fl::foreground( 255, 255, 255 );

Fl::scheme( Fl::scheme() );}
                xywh {10 10 40 25} type Radio value 1
              }
              MenuItem {} {
                label Light
                callback {Fl::background2( 255, 255, 255 );
Fl::background( 172, 172, 172 );
Fl::foreground( 0, 0, 0 );

Fl::scheme( Fl::scheme() );}
                xywh {20 20 40 25} type Radio
              }
            }
          }
        }
        MenuItem {} {
          label {&Help}
          xywh {0 0 40 25}
        }
      }
      Fl_Group {} {open
        xywh {0 23 1024 48}
      } {
        Fl_Pack {} {open
          xywh {0 23 473 46} type HORIZONTAL
          code0 {o->spacing( 10 );}
        } {
          Fl_Box {} {
            label {<Transport>}
            xywh {0 23 184 46} color 30
            code0 {transport = o;}
            code1 {o->labeltype( FL_NO_LABEL );}
            class Transport
          }
          Fl_Pack clocks_pack {open
            xywh {185 23 288 46} type HORIZONTAL
            code0 {o->spacing( 2 );}
          } {
            Fl_Box playhead_clock {
              label PLAYHEAD
              xywh {185 29 137 40} box BORDER_BOX color 46
              code0 {o->type( Clock::HMS );}
              code1 {o->run( &transport->frame );}
              class Clock
            }
            Fl_Box {} {
              label PLAYHEAD
              xywh {325 29 142 40} box BORDER_BOX color 46
              code0 {o->type( Clock::BBT );}
              code1 {o->run( &transport->frame );}
              class Clock
            }
          }
        }
        Fl_Box {} {
          label {<empty>}
          xywh {477 27 387 42} resizable
          code0 {o->labeltype( FL_NO_LABEL );}
        }
        Fl_Group {} {
          xywh {869 25 155 44}
        } {
          Fl_Box {} {
            label {capture:}
            xywh {869 25 56 14} labelsize 10 align 24
          }
          Fl_Box {} {
            label {playback:}
            xywh {869 41 56 14} labelsize 10 align 24
          }
          Fl_Box {} {
            label {DSP:}
            xywh {869 55 56 14} labelsize 10 align 24
          }
          Fl_Progress capture_buffer_progress {
            label {50%}
            xywh {925 25 99 14} labelsize 10
          }
          Fl_Progress cpu_load_progress {
            label {50%}
            xywh {925 55 99 14} labelsize 9
          }
          Fl_Progress playback_buffer_progress {
            label {50%}
            xywh {925 40 99 14} labelsize 10
          }
        }
      }
      Fl_Box {} {
        label {<Timeline>}
        xywh {0 72 1024 695} box FLAT_BOX color 47 labelsize 100 resizable
        code0 {timeline = o;}
        class Timeline
      }
    }
  }
  Function {update_progress( Fl_Progress *p, char *s, float v )} {open private return_type {static void}
  } {
    code {p->value( v );

snprintf( s, 5, "%d%%", (int)v );

p->label( s );} {}
  }
  Function {update_status()} {open
  } {
    code {static char cbp[5], pbp[5], clp[5];

update_progress( capture_buffer_progress, cbp, timeline->total_input_buffer_percent() );
update_progress( playback_buffer_progress, pbp, timeline->total_output_buffer_percent() );
update_progress( cpu_load_progress, clp, engine->cpu_load() );} {}
  }
  Function {update_cb( void *v )} {open return_type {static void}
  } {
    code {Fl::repeat_timeout( STATUS_UPDATE_FREQ, update_cb, v );

((TLE*)v)->update_status();} {}
  }
} 
